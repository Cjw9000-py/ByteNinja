
datatypes:
    - int <len> <order> <sign>
    - float <size>


planned:
    - parsing of simple types
    - bitpacks
    - basic branching

------ usage
struct field {
    string name;
    int age;
}

struct data {
    array<u64, field> fields;
}

write {
    'fields': [
        {
            'name': 'a',
            'age': 22,
        },
        {
            'name': 'a',
            'age': 22,
        },
        {
            'name': 'a',
            'age': 22,
        },
    ]
}


instructions:
    # data structure manipulation
    - get <field>  # get a field from input
    - put <field>  # put a field into output

    # array manipulation
    - empty <name> # start a new array
    - edit <name> <field> # load a existing array from a field
    - flip <name>  # flip the array ?
    - yield <name> # remove the last value from the array and place onto stack
    - append <name> # append the value to the array (value taken from stack)
    - index <n> # put a value from an array onto stack
    - finish <name> # move the array onto stack
    - forget <name> # free the array

    # stack manipulation
    - push <primitive value> # push a primitive to the stack
    - place <field> # place a value from stack into output and pop it
    - pop # pop a value from stack

    # stream manipulation
    - seek <mode>  # jump to a position in the stream (taken from stack)
    - tell # push the current stream pos to the stack

    # input ops
    - read <type> # read a type from input (can be a complex type)
    - rarray <type> # read a type x times (x is taken from stack)

    # output ops
    - write <type> # write the type to output with the value from stack
    - warray <type> # write a type x times (x is taken from stack)

    # branching
    - loop <instruction count>  # loop the next x instructions until break inst
    - loopx <times> <instruction count>  # loop the next x instructions n times
    - break # break the current loop
    - test <op> <instruction count> # test a condition
                (where left and right operand is taken from stack)
    - ret # end the processing of current type
    # - goto <offset> # go to the specified offset

    # strings
    - encode <encoding> # encode an array from the stack
    - decode <encoding> # decode an array from the stack

# all integers are encoded in little endian
code object:
    struct name_table{
        u64 size;
        struct {
            cstring name;
        } entries[size];
    };
    instructions ...


instruction encoding:
    instruction op code = 1 byte
    names = 8 bytes
    array_nos = 2 bytes
    instruction counts = 8 bytes
    primitive values = 8 bytes



---- test program
input:
    <4 bytes count>
    <4 bytes len><len bytes data> * count

output struct:
    struct ... {
         array<array>
    }

code:
    read(int, 4, little, unsigned)

    loopx {
        read(int 1, ...)
        put append
    }

